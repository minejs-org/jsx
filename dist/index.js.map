{"version":3,"sources":["../src/mod/runtime.ts","../src/mod/render.ts"],"names":["jsx","type","props","createHTMLElement","jsxs","Fragment","fragment","normalizeChildren","child","element","key","value","appendChildren","handleRef","handleEvent","handleClassName","handleStyle","isSignal","handleReactiveProp","parent","children","textNode","effect","ref","eventName","handler","event","className","styles","applyStyles","cssKey","m","signal","component","fn","defineComponent","setup","createElements","elements","el","Show","placeholder","currentElement","when","condition","Switch","caseItem","For","container","each","items","item","index","updateQueue","isFlushPending","render","options","target","newElement","mount","createPortal","hydrate","targetElement","lazy","loader","fallback","loadedComponent","loading","error","errorDiv","module","err","createLoadingElement","div","ErrorBoundary","Suspense","Teleport","queueUpdate","flushUpdates","updates","isBrowser","onDOMReady","callback","createRoot","mounted"],"mappings":"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","file":"index.js","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n// src/mod/runtime.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { effect, isSignal, type Signal } from '@minejs/signals';\n    import type { JSXElement, JSXProps, ComponentFunction } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Creates a DOM element from JSX\n     * This is called automatically by TypeScript when it sees JSX syntax\n     */\n    export function jsx(\n    type: string | ComponentFunction,\n    props: JSXProps | null\n    ): JSXElement | null {\n    // Handle component (function)\n    if (typeof type === 'function') {\n        return type(props || {});\n    }\n\n    // Handle HTML element (string)\n    return createHTMLElement(type, props || {});\n    }\n\n    /**\n     * Same as jsx() but for elements with multiple children\n     * (Used by TypeScript JSX transform)\n     */\n    export const jsxs = jsx;\n\n    /**\n     * Fragment component (like React.Fragment)\n     */\n    export function Fragment(props: { children?: any }): DocumentFragment {\n    const fragment = document.createDocumentFragment();\n    const children = normalizeChildren(props.children);\n\n    children.forEach(child => {\n        if (child instanceof Node) {\n        fragment.appendChild(child);\n        }\n    });\n\n    return fragment;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\n\n    // ============================================================================\n    // HTML ELEMENT CREATION\n    // ============================================================================\n\n    function createHTMLElement(type: string, props: JSXProps): Element {\n    const element = document.createElement(type);\n\n    // Set properties and attributes\n    for (const [key, value] of Object.entries(props)) {\n        if (key === 'children') {\n        // Handle children separately\n        appendChildren(element, value);\n        } else if (key === 'ref') {\n        // Handle ref\n        handleRef(element as HTMLElement, value);\n        } else if (key.startsWith('on')) {\n        // Handle events (onClick, onInput, etc)\n        handleEvent(element, key, value);\n        } else if (key === 'className' || key === 'class') {\n        // Handle className/class\n        handleClassName(element, value);\n        } else if (key === 'style') {\n        // Handle inline styles\n        handleStyle(element as HTMLElement, value);\n        } else if (isSignal(value)) {\n        // Handle reactive props\n        handleReactiveProp(element, key, value);\n        } else if (typeof value === 'boolean') {\n        // Handle boolean attributes (disabled, checked, etc)\n        if (value) {\n            element.setAttribute(key, '');\n        }\n        } else if (value != null) {\n        // Handle static props\n        element.setAttribute(key, String(value));\n        }\n    }\n\n    return element;\n    }\n\n    // ============================================================================\n    // CHILDREN HANDLING\n    // ============================================================================\n\n    function appendChildren(parent: Element, children: any): void {\n    const normalized = normalizeChildren(children);\n\n    normalized.forEach(child => {\n        if (child instanceof Node) {\n        parent.appendChild(child);\n        } else if (isSignal(child)) {\n        // Reactive text node\n        const textNode = document.createTextNode('');\n        effect(() => {\n            textNode.textContent = String(child());\n        });\n        parent.appendChild(textNode);\n        } else if (child != null && child !== false) {\n        // Static text node\n        parent.appendChild(document.createTextNode(String(child)));\n        }\n    });\n    }\n\n    function normalizeChildren(children: any): any[] {\n    if (children == null || children === false) {\n        return [];\n    }\n\n    if (Array.isArray(children)) {\n        return children.flatMap(normalizeChildren);\n    }\n\n    return [children];\n    }\n\n    // ============================================================================\n    // REF HANDLING\n    // ============================================================================\n\n    function handleRef(element: HTMLElement, ref: any): void {\n    if (isSignal(ref)) {\n        ref.set(element);\n    } else if (typeof ref === 'function') {\n        ref(element);\n    }\n    }\n\n    // ============================================================================\n    // EVENT HANDLING\n    // ============================================================================\n\n    function handleEvent(element: Element, eventName: string, handler: any): void {\n    if (typeof handler !== 'function') return;\n\n    // Convert onClick → click, onInput → input, etc\n    const event = eventName.slice(2).toLowerCase();\n\n    element.addEventListener(event, handler);\n    }\n\n    // ============================================================================\n    // CLASS NAME HANDLING\n    // ============================================================================\n\n    function handleClassName(element: Element, value: any): void {\n    if (isSignal(value)) {\n        // Reactive className\n        effect(() => {\n        const className = value();\n        if (className != null) {\n            element.className = String(className);\n        }\n        });\n    } else if (value != null) {\n        // Static className\n        element.className = String(value);\n    }\n    }\n\n    // ============================================================================\n    // STYLE HANDLING\n    // ============================================================================\n\n    function handleStyle(element: HTMLElement, value: any): void {\n    if (isSignal(value)) {\n        // Reactive style object\n        effect(() => {\n        const styles = value();\n        applyStyles(element, styles);\n        });\n    } else {\n        // Static style\n        applyStyles(element, value);\n    }\n    }\n\n    function applyStyles(element: HTMLElement, styles: any): void {\n    if (typeof styles === 'string') {\n        element.style.cssText = styles;\n    } else if (typeof styles === 'object' && styles != null) {\n        Object.entries(styles).forEach(([key, value]) => {\n        if (value != null) {\n            // Convert camelCase to kebab-case\n            const cssKey = key.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);\n            element.style.setProperty(cssKey, String(value));\n        }\n        });\n    }\n    }\n\n    // ============================================================================\n    // REACTIVE PROP HANDLING\n    // ============================================================================\n\n    function handleReactiveProp(element: Element, key: string, signal: Signal<any>): void {\n    effect(() => {\n        const value = signal();\n\n        if (value != null) {\n        if (key in element) {\n            // Set as property (for input.value, etc)\n            ;(element as any)[key] = value;\n        } else {\n            // Set as attribute\n            element.setAttribute(key, String(value));\n        }\n        } else {\n        element.removeAttribute(key);\n        }\n    });\n    }\n\n    /**\n     * Create a component from a function\n     * Provides a cleaner API than raw JSX\n     */\n    export function component<P = any>(\n    fn: (props: P) => JSXElement | null\n    ): ComponentFunction<P> {\n    return fn;\n    }\n\n    /**\n     * Create a component with setup function\n     * Similar to Vue's Composition API\n     */\n    export function defineComponent<P = any>(\n    setup: (props: P) => () => JSXElement | null\n    ): ComponentFunction<P> {\n    return (props: P) => {\n        const render = setup(props);\n        return render();\n    };\n    }\n\n    // ============================================================================\n    // UTILITY FUNCTIONS\n    // ============================================================================\n\n    /**\n     * Create multiple elements at once\n     */\n    export function createElements(elements: any[]): DocumentFragment {\n    const fragment = document.createDocumentFragment();\n\n    elements.forEach(el => {\n        if (el instanceof Node) {\n        fragment.appendChild(el);\n        }\n    });\n\n    return fragment;\n    }\n\n    /**\n     * Show/hide element based on condition\n     */\n    export function Show(props: {\n    when: boolean | Signal<boolean>\n    children: any\n    }): JSXElement | null {\n    if (isSignal(props.when)) {\n        const placeholder = document.createComment('show');\n        const parent = document.createDocumentFragment();\n        parent.appendChild(placeholder);\n\n        let currentElement: Element | null = null;\n\n        effect(() => {\n        const when = props.when as Signal<boolean>;\n        const condition = when();\n\n        if (condition && !currentElement) {\n            // Show: create and insert element\n            const children = normalizeChildren(props.children);\n            currentElement = children[0] as Element;\n\n            if (currentElement instanceof Node) {\n            placeholder.parentNode?.insertBefore(currentElement, placeholder);\n            }\n        } else if (!condition && currentElement) {\n            // Hide: remove element\n            currentElement.remove();\n            currentElement = null;\n        }\n        });\n\n        return parent as any;\n    } else {\n        // Static condition\n        return (props.when as boolean) ? jsx(Fragment, { children: props.children }) : null;\n    }\n    }\n\n    /**\n     * Render different elements based on condition\n     */\n    export function Switch(props: {\n    children: { when: boolean | Signal<boolean>; children: any }[]\n    }): JSXElement | null {\n    // Find first matching case\n    for (const caseItem of props.children) {\n        const condition = isSignal(caseItem.when) ? caseItem.when() : caseItem.when;\n\n        if (condition) {\n        return jsx(Fragment, { children: caseItem.children });\n        }\n    }\n\n    return null;\n    }\n\n    /**\n     * Iterate over array and render elements\n     */\n    export function For<T>(props: {\n    each: T[] | Signal<T[]>\n    children: (item: T, index: number) => JSXElement\n    }): JSXElement {\n    const fragment = document.createDocumentFragment();\n\n    if (isSignal(props.each)) {\n        // Reactive list\n        const container = document.createElement('div');\n        container.style.display = 'contents'; // Don't affect layout\n\n        effect(() => {\n        const each = props.each as Signal<T[]>;\n        const items = each();\n        container.innerHTML = ''; // Clear\n\n        items.forEach((item: any, index: any) => {\n            const element = props.children(item, index);\n            if (element instanceof Node) {\n            container.appendChild(element);\n            }\n        });\n        });\n\n        fragment.appendChild(container);\n    } else {\n        // Static list\n        const each = props.each as T[];\n        each.forEach((item, index) => {\n        const element = props.children(item, index);\n        if (element instanceof Node) {\n            fragment.appendChild(element);\n        }\n        });\n    }\n\n    return fragment as any;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\n\n    export default {\n        jsx,\n        jsxs,\n        Fragment,\n        component,\n        defineComponent,\n        Show,\n        Switch,\n        For,\n        createElements\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","/* eslint-disable @typescript-eslint/no-explicit-any */\n// src/mod/render.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { JSXElement, RenderOptions, MountedComponent } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    let updateQueue: (() => void)[] = [];\n    let isFlushPending = false;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Render a component to the DOM\n     * @param component - Component or JSX element to render\n     * @param container - DOM element or selector to mount to\n     * @param options - Rendering options (mode, callbacks)\n     * @returns MountedComponent with unmount and update methods\n     * @throws Error if container not found or component returns null\n     * @example\n     * const el = jsx('div', { children: 'Hello' });\n     * render(el, document.body);\n     */\n    export function render(\n    component: JSXElement | (() => JSXElement),\n    container: HTMLElement | string,\n    options: RenderOptions = {}\n    ): MountedComponent {\n    // Resolve container\n    const target = typeof container === 'string'\n        ? document.querySelector(container)\n        : container;\n\n    if (!target) {\n        throw new Error(`Container not found: ${container}`);\n    }\n\n    // Get element from component\n    const element = typeof component === 'function' ? component() : component;\n\n    if (!element) {\n        throw new Error('Component returned null or undefined');\n    }\n\n    // Mount to DOM based on mode\n    const mode = options.mode || 'replace';\n\n    switch (mode) {\n        case 'replace':\n        target.innerHTML = '';\n        target.appendChild(element as Node);\n        break;\n\n        case 'append':\n        target.appendChild(element as Node);\n        break;\n\n        case 'prepend':\n        target.insertBefore(element as Node, target.firstChild);\n        break;\n\n        default:\n        // Invalid mode, fall back to replace\n        target.innerHTML = '';\n        target.appendChild(element as Node);\n    }\n\n    // Call onMount callback\n    options.onMount?.();\n\n    // Return mounted component interface\n    return {\n        element: element as Element | DocumentFragment,\n\n        unmount: () => {\n        if (element instanceof Element) {\n            element.remove();\n        } else if (element instanceof DocumentFragment) {\n            // DocumentFragment doesn't have remove method, remove all children\n            while (element.firstChild) {\n            element.removeChild(element.firstChild);\n            }\n        }\n        options.onUnmount?.();\n        },\n\n        update: (newElement: JSXElement) => {\n        if (element instanceof Element && newElement instanceof Element) {\n            element.replaceWith(newElement);\n        } else if (newElement instanceof Element) {\n            // If current is DocumentFragment and new is Element\n            if (element instanceof DocumentFragment && element.parentNode) {\n            element.parentNode.replaceChild(newElement, element);\n            }\n        }\n        }\n    };\n    }\n\n    /**\n     * Simple mount function (alias for render with replace mode)\n     */\n    export function mount(\n    component: JSXElement | (() => JSXElement),\n    container: HTMLElement | string\n    ): MountedComponent {\n    return render(component, container, { mode: 'replace' });\n    }\n\n    /**\n     * Render component to a different location in the DOM\n     */\n    export function createPortal(\n    children: JSXElement,\n    container: HTMLElement | string\n    ): JSXElement {\n    const target = typeof container === 'string'\n        ? document.querySelector(container)\n        : container;\n\n    if (!target) {\n        throw new Error(`Portal container not found: ${container}`);\n    }\n\n    // Create a placeholder comment\n    const placeholder = document.createComment('portal');\n\n    // Mount children to target\n    if (children instanceof Node) {\n        target.appendChild(children);\n    }\n\n    return placeholder as any;\n    }\n\n    /**\n     * Hydrate server-rendered HTML with client-side interactivity\n     * @param component - Component to hydrate\n     * @param container - Container with server-rendered HTML\n     */\n    export function hydrate(\n    component: JSXElement | (() => JSXElement),\n    container: HTMLElement | string\n    ): MountedComponent {\n    const targetElement = typeof container === 'string'\n        ? document.querySelector(container)\n        : container;\n\n    const target = targetElement instanceof HTMLElement ? targetElement : null;\n\n    if (!target) {\n        throw new Error(`Container not found: ${container}`);\n    }\n\n    // For now, just replace (future: smart hydration)\n    return render(component, target, { mode: 'replace' });\n    }\n\n    /**\n     * Lazy load a component with dynamic imports\n     * @param loader - Async function that returns a component module\n     * @param fallback - Element to show while loading (optional)\n     * @returns A component that renders loaded component or fallback/error state\n     * @example\n     * const LazyComponent = lazy(() => import('./Component'), <div>Loading...</div>);\n     */\n    export function lazy<P = any>(\n    loader: () => Promise<{ default: (props: P) => JSXElement }>,\n    fallback?: JSXElement\n    ): (props: P) => JSXElement {\n    let loadedComponent: ((props: P) => JSXElement) | null = null;\n    let loading = false;\n    let error: Error | null = null;\n\n    return (props: P) => {\n        // If already loaded, return component\n        if (loadedComponent) {\n        return loadedComponent(props);\n        }\n\n        // If error occurred, show error\n        if (error) {\n        const errorDiv = document.createElement('div');\n        errorDiv.className = 'crux-lazy-error';\n        errorDiv.textContent = `Error loading component: ${error.message}`;\n        errorDiv.style.color = 'red';\n        return errorDiv;\n        }\n\n        // If not loading yet, start loading\n        if (!loading) {\n        loading = true;\n\n        loader()\n            .then(module => {\n            loadedComponent = module.default;\n            // TODO: Trigger re-render when loaded\n            })\n            .catch(err => {\n            error = err instanceof Error ? err : new Error(String(err));\n            // TODO: Trigger re-render on error\n            });\n        }\n\n        // Show fallback while loading\n        return fallback || createLoadingElement();\n    };\n    }\n\n    function createLoadingElement(): HTMLElement {\n    const div = document.createElement('div');\n    div.textContent = 'Loading...';\n    return div;\n    }\n\n    /**\n     * Error boundary component\n     */\n    export function ErrorBoundary(props: {\n    fallback: (error: Error) => JSXElement\n    children: JSXElement\n    }): JSXElement {\n    try {\n        return props.children;\n    } catch (error) {\n        return props.fallback(error as Error);\n    }\n    }\n\n    /**\n     * Suspense component for handling loading states\n     */\n    export function Suspense(props: {\n    fallback: JSXElement\n    children: JSXElement | Promise<JSXElement>\n    }): JSXElement {\n    if (props.children instanceof Promise) {\n        // Create container for async content\n        const container = document.createElement('div');\n        container.style.display = 'contents';\n\n        // Show fallback first\n        if (props.fallback instanceof Node) {\n        container.appendChild(props.fallback);\n        }\n\n        // Load actual content\n        props.children.then(element => {\n        container.innerHTML = '';\n        if (element instanceof Node) {\n            container.appendChild(element);\n        }\n        });\n\n        return container;\n    } else {\n        return props.children;\n    }\n    }\n\n    /**\n     * Teleport component (like Vue's Teleport)\n     */\n    export function Teleport(props: {\n    to: string | HTMLElement\n    children: JSXElement\n    }): JSXElement {\n    return createPortal(props.children, props.to);\n    }\n\n    /**\n     * Queue a DOM update to be batched\n     */\n    export function queueUpdate(fn: () => void): void {\n    updateQueue.push(fn);\n\n    if (!isFlushPending) {\n        isFlushPending = true;\n        queueMicrotask(flushUpdates);\n    }\n    }\n\n    /**\n     * Flush all queued updates\n     */\n    function flushUpdates(): void {\n    const updates = updateQueue;\n    updateQueue = [];\n    isFlushPending = false;\n\n    updates.forEach(fn => fn());\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\n\n    /**\n     * Check if code is running in browser\n     */\n    export function isBrowser(): boolean {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n    }\n\n    /**\n     * Wait for DOM to be ready\n     */\n    export function onDOMReady(callback: () => void): void {\n    if (isBrowser()) {\n        if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', callback);\n        } else {\n        callback();\n        }\n    }\n    }\n\n    /**\n     * Create a root for rendering\n     */\n    export function createRoot(container: HTMLElement | string) {\n    const target = typeof container === 'string'\n        ? document.querySelector(container)\n        : container;\n\n    if (!target || !(target instanceof HTMLElement)) {\n        throw new Error(`Root container not found: ${container}`);\n    }\n\n    let mounted: MountedComponent | null = null;\n\n    return {\n        render(component: JSXElement | (() => JSXElement)) {\n        if (mounted) {\n            mounted.unmount();\n        }\n        mounted = render(component, target);\n        },\n\n        unmount() {\n        if (mounted) {\n            mounted.unmount();\n            mounted = null;\n        }\n        }\n    };\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\n\n    export default {\n    render,\n    mount,\n    hydrate,\n    createPortal,\n    lazy,\n    ErrorBoundary,\n    Suspense,\n    Teleport,\n    createRoot,\n    onDOMReady,\n    isBrowser,\n    queueUpdate\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n"]}